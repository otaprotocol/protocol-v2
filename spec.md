
Action Codes Protocol – Modern Redesign

Core Principles 1. Protocol is chain-agnostic – it only validates codes and signatures. 2. Delegated authorities supported – wallets can delegate signing to devices/keys. 3. No prefix system required – trust is guaranteed by code signature. 4. Metadata is optional but structured – KV params limited in length for safety. 5. Relayers/platforms handle transport – sign, submit transactions, or forward messages.

⸻

1. Action Code Object

interface ActionCode<T = any> {
code: string; // Short deterministic code (6–24 chars)
pubkey: string; // Wallet or signer public key
timestamp: number; // Milliseconds since epoch
expiresAt: number; // Absolute expiration
signature: string; // Ed25519 or delegated signature
metadata?: {
description?: string; // Optional human-readable description
params?: Record<string, T>; // Optional KV params (length-limited)
};
chain?: string; // Optional chain for multi-chain support
mode: 'wallet' | 'delegated'; // Signing mode
}

    •	params can be any JSON object but must be a KV map.
    •	Enforce maximum JSON string length (e.g., 1KB) to avoid abuse.
    •	mode indicates whether the code was signed directly by wallet or delegated authority.

⸻

2. Code Generation & Validation

Generation
• Wallet or delegated key signs the canonical string:

canonical_message = code + timestamp + optional metadata hash

    •	Deterministic hash → code
    •	Code + signature + metadata → ActionCode object

Validation
• Protocol validates: 1. Code exists and is within TTL (timestamp ≤ now ≤ expiresAt) 2. Signature matches pubkey or delegated key 3. Metadata length & structure if present (optional params KV)
• Protocol does not validate transactions or messages — only the code and signature.

⸻

3. Delegated Authenticators
   • Users can delegate signing via ephemeral keys:

{
"wallet_pubkey": "...",
"auth_pubkey": "...",
"not_before": 1695800000000,
"not_after": 1727336000000,
"signature": "..." // wallet signature over above fields
}

    •	Relayers or services verify:
    1.	Delegation is valid (signature, not_before / not_after)
    2.	Requested code falls within scope
    3.	Code signature verifies with auth_pubkey

⸻

4. Protocol Responsibilities
   • Only asserts code integrity, signature, TTL, optional metadata.
   • Provides SDKs/adapters to validate codes for different wallet types (Solana, Ethereum, etc.).
   • Offers utility helpers for:
   • Generating canonical message strings
   • Signing/validating codes
   • Delegated authenticator verification
   • Metadata KV validation

⸻

5. Relayer / Platform Responsibilities
   • Accept codes and optionally attach to:
   • Blockchain transaction
   • Off-chain message
   • Internal API
   • Handle:
   • Rate limiting / anti-abuse
   • Origin validation
   • Delegation scoping
   • Optional signing / forwarding
   • Protocol trust = code signature only (stateless)

⸻

6. Metadata Rules
   • Optional, structured, KV format
   • Max JSON length: configurable (e.g., 1KB)
   • Protocol does not enforce specific keys, only safe structure
   • Example:

{
"description": "Pay 2 USDC",
"params": {
"amount": "2",
"token": "USDC",
"recipient": "SomeWalletPubkey"
}
}

⸻

7. Security Model
   • Stateless – no central authority needed
   • Deterministic & Time-bound – each code valid for TTL only
   • Delegation optional – supports passkeys, WebAuthn
   • Relayer-agnostic – transport & usage handled separately
   • Replay protection – TTL + delegation certificate + signature

⸻

8. Advantages of This Design
   • Fully prefixless, simpler and lighter than AIP-4
   • Flexible metadata allows any use case
   • Delegated authorities reduce friction for mobile/web wallets
   • Relayers don’t need special protocol registration or prefixes
   • Chain-agnostic and ready for multiple networks
   • Clean separation of protocol vs service responsibilities

⸻


Absolutely — here’s a clean, modern spec for TOTP-style Action Codes that keeps the protocol minimal but allows offline usage, delegated authorities, and flexible metadata. This supersedes the older AIP system.

⸻

Action Codes Protocol – Core Code Generation & Validation Spec

1. Purpose
	•	One-time codes that are short-lived, verifiable, and deterministic.
	•	Can be generated by wallet keys or delegated authenticators.
	•	Supports offline verification and relayer submission.
	•	Metadata is optional but structured for traceability and UX.

⸻

2. Code Generation

2.1 Canonical Message

The code is derived from a canonical message:

canonicalMessage = hash(pubkey || timestamp || optionalSecret)

Where:
	•	pubkey – the public key of the wallet or delegated authenticator.
	•	timestamp – epoch in milliseconds (or seconds) for TOTP window alignment.
	•	optionalSecret – ephemeral secret (if offline mode or delegated authorities use it).

Notes:
	•	Using a secret allows offline generation and TOTP-like behavior.
	•	The canonical message can be hashed with SHA256 or BLAKE3.

⸻

2.2 Code Format
	•	codeLength: configurable, e.g., 6–16 characters.
	•	Default TTL: 2 minutes (aligns with TOTP window).
   Canonical input: serialize(pubkey, windowStart, metadataHash?)
With secret: code = Base32(TruncateBits(HMAC-SHA256(secret, canonical), 5*codeLength))
Without secret: code = Base32(TruncateBits(SHA-256(canonical), 5*codeLength))
Encoding: Base32 (Crockford), avoid lookalikes; default length 8 chars (40 bits).
Derive secret via HKDF-SHA256 from a delegation cert or device seed to avoid raw key reuse.
Signature still required: signer verifies the same canonical message; code is not the trust anchor.

Optional fields in the generated ActionCode object:

interface ActionCode {
  code: string;             // Derived short code
  pubkey: string;           // Wallet or delegated auth pubkey
  timestamp: number;        // Generation timestamp (start of window)
  signature?: string;       // Wallet or delegated signature over canonicalMessage
  expiresAt: number;        // Expiration timestamp
  metadata?: {
    description?: string;
    params?: Record<string, any>; // Free-form KV, max length restricted
  };
  secretHint?: string;      // Optional hint for offline verification
}


⸻

2.3 Signature Modes
	1.	Mode W (Wallet)
	•	Direct wallet signature of the canonical message.
	•	Signature used for verification by protocol or relayer.
	2.	Mode A (Delegated Authenticator)
	•	Delegated certificate issued by wallet.
	•	Authenticator signs canonical message.
	•	Protocol verifies certificate signature + TTL + optional scopes.

Note: Protocol doesn’t enforce scopes or origin; those are for service/relayer checks only.

⸻

3. Validation

Protocol-level validation checks:
	1.	Recompute canonical message using pubkey, timestamp, and optional secret.
	2.	Verify signature (wallet or delegated authenticator).
	3.	Check expiresAt against current time.
	4.	Optionally validate metadata schema (description + params).

No on-chain prefix or origin checks are required at protocol level — purely signature & TTL.

⸻

4. TOTP / Offline Usage
	•	TTL windows align with timestamp (e.g., 2 minutes by default).
	•	optionalSecret allows the same code to be deterministically generated offline.
	•	Delegated authenticators can store the secret locally for session-based or offline TOTP generation.

⸻

5. Metadata
	•	description: human-readable description.
	•	params: optional KV object for relayer / app-specific usage.
	•	Length limit to avoid abuse (e.g., 1 KB max).

Example:

{
  "description": "Pay 2 USDC to vendor",
  "params": {
    "recipient": "9xTx123...",
    "amount": 2.0
  }
}


⸻

6. Relayer Role
	•	Accepts signed codes.
	•	Can optionally enforce allowlist by origin, domain, or service.
	•	Verifies canonical code signature and TTL.
	•	Attaches transaction or executes action.

Protocol does not enforce who can submit, only ensures code validity.

⸻

7. Security Considerations
	•	Replay attacks mitigated by TTL and TOTP-style generation.
	•	Delegated certificates ensure wallets remain root of trust.
	•	Offline mode possible via deterministic secret derivation.
	•	Protocol remains stateless and chain-agnostic.

⸻

This specification allows:
	•	Offline code generation
	•	Delegated authenticators
	•	Flexible metadata
	•	Stateless, minimal protocol
	•	TOTP-style security

